import os
import numpy as np
import sys
import pandas as pd
import operator
import glob
import pickle as p
import csv
import shutil
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.pylab as plt_cols
import matplotlib.cm as cm
import re
import glob

'''
This file contains the code necessary to produce the plots and results of the associated PRISMS-Fatigue manuscript that investigates the effects of different boundary conditions.
Each function contains many comments and should be intuitive to execute
The associated data is available for download at https://doi.org/10.13011/m3-mhgc-ec71
'''

# Users can simply execute this script as "python PRISMS_paper_2_effects_of_BCs.py" in a command prompt window or by using an interactive python window.
# This script should be placed in the directory that contains the "paper_#2_section_3", etc. directories that were downloaded from the Materials Commons

# Get name of directory that contains this script and the three folders of data downloaded from the Materials Common page at https://doi.org/10.13011/m3-mhgc-ec71
DIR_LOC = os.path.dirname(os.path.abspath(__file__))

'''
These first functions pull data from the directories with the following names and descriptions:

Ensemble_of_29^3_fully_periodic  : Fully periodic microstructures generated by DREAM.3D, one pair of which is shown in Fig. 5a
Ensemble_of_87^3_fully_periodic  : Padded microstructure as shown in Fig. 5a
90^3_That_We_Cut_30^3_From_Them  : Microstructure generated as fully periodic as shown in Fig. 6a
30^3_from_90^3                   : The center of the 90^3 microstructure as described above and shown in Fig. 6a

These four directories contain the data shown in Section 3 of the manuscript
'''

# NOTE: Users can use these functions by either loading in this script as an interactive python session and calling each function, or the body of each function can be copy-and-pasted into an interactive python version

def section_3_create_87_from_29_instantiations():

    # This function was used to "pad" or create repeating microstructures of 87^3 elements using previously generated microstructures with 29^3 elements cubed
    
    # The steps to create the repeating 87^3 microstructures include:
    # 1) Extend the 29^3 microstructures in the Z direction using DREAM.3D. Please see the 'Output_FakeMatl_#_extended.dream3d' and 'combine_sections.json' files in the 'Ensemble_of_87^3_fully_periodic' folder.
    # 2) The previous step generates 'grainID_#.txt' files that are three times in volume of the original 29^3 microstructure and have dimensions of 29 x 29 x 87.
    # 3) The code below then reads the 'grainID_#.txt' files from the previous step and repeats this information in the X and Y directions
    
    # NOTE: The ONLY additional task after the new 'grainID*.txt' file is created is to update the first section of the code to list '87 87 87' as the dimensions instead of 87 29 29
    
    # Define the original size of periodic microstructure
    ms_og_size = np.asarray([29,29,29])
    
    # Define directory with 87^3 microstructure files
    directory = os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_87^3_fully_periodic')
    os.chdir(directory)

    for FILE_NUM in range(5):

        # Read in text file
        fname = 'grainID_%d.txt' % FILE_NUM
        h1 = open(fname, 'r')

        # Quickly go through the first set of lines
        top_of_file = []

        for ii in range(20):
            l1 = h1.readline()
            top_of_file.append(l1)
           
        lines = []
        # Start reading actual contents of file
        for ii in range(ms_og_size[0]*ms_og_size[1]):
            lines.append(h1.readline())

        bottom_of_file = []

        for ii in range(11):
            l2 = h1.readline()
            bottom_of_file.append(l2)


        new_lines = []
        # Duplicate every ms_og_size[1] lines by 3 to extend in the Y
        for ii in range(ms_og_size[0]):
            for kk in range(3):
                new_lines.append(lines[29*ii:29*(ii+1)])

        f_new = 'grainID_%d_full_v1.txt' % FILE_NUM
        h2 = open(f_new, 'w')
        for x1 in top_of_file:
            h2.write(x1)
            
        for pp in range(3):
            # Repeat this three times to iterate through the X direction
            for xx in range(ms_og_size[0]*3):
                for yy in range(ms_og_size[0]):
                    h2.write(new_lines[xx][yy])
                
        for x1 in bottom_of_file:
            h2.write(x1)
        h2.close()

def section_3_stress_strain_curve_29_87_instantiation_0():

    # This function will plot and compare the stress-strain response of a single pair of microstructures from Section 3 of the manuscript.
    # The macroscopic stress-strain response of a single pair of 29^3 and 87^3 microstructures is compared because the macroscale response is identical.
    # As a reminder, the response of the entire 29^3 microstructure is compared to THE CENTER 29^3 region of the 87^3 microstructure.
    
    # Define directory where plots should be stored
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_3')
    
    # Define directory where the larger 87^3 microstructure data is stored    
    # directory = r'G:\PRISMS_paper_#2_feb_16th\paper_#2_section_3\Ensemble_of_87^3_fully_periodic\_Random_equiaxed_0'
    directory = os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_87^3_fully_periodic\_Random_equiaxed_0')
    
    # Go to directory
    os.chdir(directory)

    # Specify the size of the region of interest and the padding in each direction that should be disregarded
    size = np.asarray((29,29,29))
    
    # The padding is set to 29 because the original microstructure is repeated in each direction (see Fig. 5a of manuscript).
    padding = 29
    

    # Initialize empty arrays
    strain_z_87 = [0]
    stress_z_87 = [0]

    # Iterate through each quadrature output point and extract the stress and strain of the center region
    # IMPORTANT: This for loop will take a while to read, but only needs to be executed once. The user can then modify how the data is plotted at the end of this function
    for num in np.arange(19,700,20):
        
        # Define each file name
        file_dirr = os.path.join(directory, 'QuadratureOutputs%d.csv' % num)
        
        print('Reading file: %s' % ('QuadratureOutputs%d.csv' % num))
        
        # Read in data using pandas module
        data2 = pd.read_csv(file_dirr, index_col = False)
        
        # Sort by x, then y, then z
        data1 = data2.sort_values(['z','y','x'], ascending = [True, True, True])

        # Extract the results FROM THE CENTER 29^3 REGION OF THE 87^3 MICROSTRUCTURE
        mid_vals_x = data1.x.unique()[padding:padding+size[2]]
        mid_vals_y = data1.y.unique()[padding:padding+size[2]]
        mid_vals_z = data1.z.unique()[padding:padding+size[2]]
        
        # Define the center region
        mid_region = data1.loc[data1['x'].isin(mid_vals_x) & data1['y'].isin(mid_vals_y) & data1['z'].isin(mid_vals_z)]
        
        # Get average of strain in Z of the center region 
        strain_z_temp = np.mean(mid_region['Ezz'])
        strain_z_87.append(strain_z_temp)
        
        # Get average of stress in Z of the center region 
        stress_z_temp = np.mean(mid_region['Tzz'])
        stress_z_87.append(stress_z_temp)
        
    
    # Now repeat this for the original microstructure that is 29^3 in size
    # directory = r'G:\PRISMS_paper_#2_feb_16th\paper_#2_section_3\Ensemble_of_29^3_fully_periodic\_Random_equiaxed_0'
    directory = os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_29^3_fully_periodic\_Random_equiaxed_0')
    
    os.chdir(directory)
    
    # Initialize empty arrays
    strain_z_29 = [0]
    stress_z_29 = [0]

    for num in np.arange(19,700,20):
        
        # Define each file name
        file_dirr = os.path.join(directory, 'QuadratureOutputs%d.csv' % num)
        
        print('Reading file: %s' % ('QuadratureOutputs%d.csv' % num))
        
        # Read in data using pandas module
        data2 = pd.read_csv(file_dirr, index_col = False)
        data1 = data2.sort_values(['z','y','x'], ascending = [True, True, True])

        # This section is excluded because we do not need "extract" the center of the 29^3 microstructures
        # mid_vals_x = data1.x.unique()[padding:padding+size[2]]
        # mid_vals_y = data1.y.unique()[padding:padding+size[2]]
        # mid_vals_z = data1.z.unique()[padding:padding+size[2]]
        
        # mid_region = data1.loc[data1['x'].isin(mid_vals_x) & data1['y'].isin(mid_vals_y) & data1['z'].isin(mid_vals_z)]
        
        # Get average of strain in Z 
        strain_z_temp = np.mean(data1['Ezz'])
        strain_z_29.append(strain_z_temp)
        
        # Get average of stress in Z 
        stress_z_temp = np.mean(data1['Tzz'])
        stress_z_29.append(stress_z_temp)    
    
    
    
    
    # Plot stress-strain curve    
    
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
    
    # Plot each data set
    plt.plot(strain_z_29,stress_z_29, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Periodic $29^3$ microstructure simulated with PBCs')
    plt.plot(strain_z_87,stress_z_87, marker = 'o', color = 'b', markersize = 2,                  label = '$29^3$ region extracted from repeated $87^3$ microstructure')
    plt.plot(strain_z_29,stress_z_29, color = 'r',  linestyle = ':')

    # Include a legend
    plt.legend(bbox_to_anchor=(0.0, 1.1), loc='upper left', framealpha = 1, fontsize = 9)
    
    plt.ylabel('Stress [MPa]')   
    plt.grid(True)
    plt.xlabel('Strain')
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    
    # Save the figure
    plt.savefig(os.path.join(store_dirr, '29_87_stress_strain_comparison'))
    plt.close()

def section_3_extract_center_results():
    # This function specifically reads in a .csv results file from PRISMS-Plasticity simulations and save it as a new file with only the results of the center region
    
    # NOTE: Users will notice both "MaxComp_0.csv" and "MaxComp_0_middle.csv" files in some of these directories. They are produced using this code
    
    # Inputs:
    #     padding     = Specify the number of elements that 'pad' the microstructure and should be removed
    #     num         = Number of instantiations
    #     size        = np.array((x,y,z)) size of the original microstructure
    
    # Define directories
    directories = [os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_87^3_fully_periodic'),
                   os.path.join(DIR_LOC, r'paper_#2_section_3\90^3_That_We_Cut_30^3_From_Them')]
    
    # Define number of instantiations
    num = 5
    
    # Define sizes
    size = np.asarray([29, 30])
    
    # Define paddings
    padding = [29, 30]


    for pp, directory in enumerate(directories):
        os.chdir(directory)

        # Iterate through some number of files
        for ii in range(num):
            
            # Run this for loop for "MaxTen..." below, then rerun for "MaxComp..."
            fname = os.path.join(directory, 'MaxComp_%d.csv' % ii)
            
            # Read in file
            c1 = pd.read_csv(fname, index_col = False)

            # Sort by x, then y, then z
            sorted_1 = c1.sort_values(['z','y','x'], ascending = [True, True, True])

            # Determine what elements are in the center
            mid_vals_x = sorted_1.x.unique()[padding[pp]:padding[pp]+size[pp]]
            mid_vals_y = sorted_1.y.unique()[padding[pp]:padding[pp]+size[pp]]
            mid_vals_z = sorted_1.z.unique()[padding[pp]:padding[pp]+size[pp]]
            
            # This section is omitted because this code was also used for the analysis in section 4 where only the CENTER 90^3 region of each microstructure was considered (i.e., each microstructure that was progressively extended in the Z direction)
            # mid_vals_x = sorted_1.x.unique()
            # mid_vals_y = sorted_1.y.unique()
            # mid_vals_z = sorted_1.z.unique()[padding:padding+size[2]]

            # Define the center region
            mid_region = sorted_1.loc[sorted_1['x'].isin(mid_vals_x) & sorted_1['y'].isin(mid_vals_y) & sorted_1['z'].isin(mid_vals_z)]

            # Save to a new file and rename with the suffix "middle"
            mid_region.to_csv(os.path.join(directory, 'MaxComp_%d_middle.csv' % ii), index = False)
         
         
         
         
            # The code is repeated for the files at the point of maximum tension as shown below
            
            # Run this for loop for "MaxTen..." below, then rerun for "MaxComp..."
            fname = os.path.join(directory, 'MaxTen_%d.csv' % ii)

            c1 = pd.read_csv(fname, index_col = False)

            sorted_1 = c1.sort_values(['z','y','x'], ascending = [True, True, True])

            mid_vals_x = sorted_1.x.unique()[padding[pp]:padding[pp]+size[pp]]
            mid_vals_y = sorted_1.y.unique()[padding[pp]:padding[pp]+size[pp]]
            mid_vals_z = sorted_1.z.unique()[padding[pp]:padding[pp]+size[pp]]

            # mid_vals_x = sorted_1.x.unique()
            # mid_vals_y = sorted_1.y.unique()
            # mid_vals_z = sorted_1.z.unique()[padding:padding+size[2]]

            mid_region = sorted_1.loc[sorted_1['x'].isin(mid_vals_x) & sorted_1['y'].isin(mid_vals_y) & sorted_1['z'].isin(mid_vals_z)]

            # Save to a new file and rename with the suffix "middle"
            mid_region.to_csv(os.path.join(directory, 'MaxTen_%d_middle.csv' % ii), index = False)

def section_3_extract_and_store_local_values():
    # Function to import data from PRISMS-plasticity simulations and save as pickle file for volume averaging
    
    # Define directories:
    directories = [os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_29^3_fully_periodic'),
                   os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_87^3_fully_periodic'),
                   os.path.join(DIR_LOC, r'paper_#2_section_3\30^3_from_90^3'),
                   os.path.join(DIR_LOC, r'paper_#2_section_3\90^3_That_We_Cut_30^3_From_Them')]
    
    # Define whether to extract results from the center regions or not (only True for the larger microstructures, 90^3 and 87^3)
    extract_center = [False, True, False, True]
    
    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_3')
    
    num = 5
    
    # Iterate throuh directories:
    
    for pp, directory in enumerate(directories):
        # Change directory
        os.chdir(directory)
        
        for num_f in range(num):
            # Specify files with simulations values at points of maximum compression and maximum tension
            if extract_center[pp]:
                dirr_max_comp = os.path.join(directory, 'MaxComp_%d_middle.csv' % num_f)
                dirr_max_tens = os.path.join(directory, 'maxTen_%d_middle.csv' % num_f)
            else:
                dirr_max_comp = os.path.join(directory, 'MaxComp_%d.csv' % num_f)
                dirr_max_tens = os.path.join(directory, 'maxTen_%d.csv' % num_f)

            # Read in data using pandas module
            aver_comp = pd.read_csv(dirr_max_comp, index_col = False)
            aver_tens = pd.read_csv(dirr_max_tens, index_col = False)
            # "index_col = False" means that the first column is NOT the index, which is the case in the quadrature output files here.
            
            
            # NOTE: the default PRISMS-Fatigue quadrature output columns correspond to the following values for each quadrature point (or element in the case of simulations with reduced integration elements)
            # The first four columns do not change during the simulation. The remaining columns correspond to current values of state variables
            # Grain ID, x position, y position, z position, plastic shear strain for slip systems 1 thru 12, stress normal to slip planes of slip systems 1 thru 12, plastic strain tensor in global directions (i.e., Ep11, Ep12, Ep13	Ep21, Ep22, Ep23, Ep31, Ep32, Ep33), Effective plastic strain


            # PRISMS can employ full integration elements, but reduced integration is employed for PRISMS-Fatigue
            # If full integration is used, please uncomment these lines of code to average values over the eight integration points per element
            # aver_comp_2 = pd.DataFrame(np.einsum('ijk->ik',aver_comp.values.reshape(-1,8,aver_comp.shape[1]))/8.0, columns=aver_comp.columns)
            # aver_tens_2 = pd.DataFrame(np.einsum('ijk->ik',aver_tens.values.reshape(-1,8,aver_tens.shape[1]))/8.0, columns=aver_tens.columns)
           
            # If reduced intergration performed in PRISMS, there is no need to average over eight integration points per element (two lines of code directly above)
            aver_comp_2 = aver_comp
            aver_tens_2 = aver_tens
            
            # Sort by X, then Y, then Z, since PRISMS discretizes the domain for parallelization.
            # Values must be sorted this way to match the way microstructures are instantiated using the generate_microstructure.py script! 
            # Positions in X, Y, and Z directions corresponds to columns 1 thru 3, respectively
            aver_comp_2_sorted = aver_comp_2.sort_values(['z','y','x'], ascending = [True, True, True])
            aver_tens_2_sorted = aver_tens_2.sort_values(['z','y','x'], ascending = [True, True, True])

            # Calculate plastic shear strain range
            # If a new FIP is specified, the column names in the .csv files will be read in according to the nomenclature below!
            # Corresponds to columns 4 thru 15
            delta_gamma     = (aver_tens_2_sorted - aver_comp_2_sorted) * 0.5
            slip_values     = abs(delta_gamma[['slip_' + str(i) for i in range(1,13)]]) 
            
            eff_slip = aver_tens_2_sorted['EpEff']
            
            slip_values_np = slip_values.to_numpy()

            fname = 'slip_values_%d.p' % num_f
            h1 = open(fname, 'wb')
            p.dump([eff_slip, slip_values_np],h1)
            h1.close()

def section_3_plot_local_slip_29_87():
    # Function to plot and compare local measures of slip 
    
    # Define directories
    dir_29_from_87 = os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_29^3_fully_periodic')
    dir_87_center  = os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_87^3_fully_periodic')
    
    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_3')
    
    n_bins = 100
    
    # Iterate through each folder, read in values, then plot
    for num in range(5):
    
        fname = os.path.join(dir_29_from_87, 'slip_values_%d.p' % num)
        h1 = open(fname, 'rb')
        eff_slip_30_from_90, slip_values_30_from_90 = p.load(h1)
        h1.close()
        
        fname1 = os.path.join(dir_87_center, 'slip_values_%d.p' % num)
        h2 = open(fname1, 'rb')
        eff_slip_90_center, slip_values_90_center = p.load(h2)
        h2.close() 
        

    
        fig = plt.figure(facecolor="white", figsize=(5, 3.666), dpi=1200)
        
        
        n,x1,_ = plt.hist(eff_slip_30_from_90, bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers,n1, label = 'Periodic $29^3$ microstructure simulated with PBCs', color = 'b')
        
        
        n,x1,_ = plt.hist(eff_slip_90_center, bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers,n1, label = '$29^3$ region extracted from repeated $87^3$ microstructure', linestyle = ':', color = 'r')        
        
        
        
        #plt.show()
        plt.legend(bbox_to_anchor=(0.13, 1.15), loc='upper left', framealpha = 1, fontsize = 8)
        plt.ylabel('Num')   
        plt.grid(True)
        plt.xlabel('Cumulative effective plastic strain')       
        plt.ticklabel_format(style = 'sci', axis='both', scilimits=(0,0), useMathText = True)    
        plt.tight_layout()
        plt.savefig( os.path.join(store_dirr, '29_87_cumulative_effective_plastic_strain_histograms_%d_bins_inst_%d' % (n_bins, num)) )
        plt.close()        

def section_3_plot_highest_SBA_per_grain_29_87():
    # This function first requires users to calculate FIPs using the calculate_FIPs.py and volume_average_FIPs.py scripts!

    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_3')
    
    # Get FIPs from 87^3 first microstructure
    directory = os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_87^3_fully_periodic')
    os.chdir(directory)

    fname = r'sub_band_averaged_highest_per_grain_FS_FIP_0.csv'
    data2 = pd.read_csv(fname, index_col = False)
    fips_87_pd = data2['SubBandAveragedFipValue']
    fips_87 = fips_87_pd.to_numpy()

    
    # Get FIPs from 29^3 first microstructure
    directory = os.path.join(DIR_LOC, r'paper_#2_section_3\Ensemble_of_29^3_fully_periodic')
    os.chdir(directory)

    fname = r'sub_band_averaged_highest_per_grain_FS_FIP_0.csv'
    data1 = pd.read_csv(fname, index_col = False)
    fips_29_pd = data1['SubBandAveragedFipValue']
    fips_29 = fips_29_pd.to_numpy()


    # Plot figure
    
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
    
    plt.plot(range(1, len(fips_29)+1),fips_29, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Periodic $29^3$ microstructure simulated with PBCs')
    plt.plot(range(1, len(fips_87)+1),fips_87, marker = 'o', color = 'b', markersize = 2,                  label = '$29^3$ region extracted from repeated $87^3$ microstructure')
    plt.plot(range(1, len(fips_29)+1),fips_29, color = 'r', linestyle = ':')

    plt.legend(loc='lower left', framealpha = 1, fontsize = 8.5)
    
    #plt.show()
    plt.ylabel('Sub-band-averaged FIP')   
    plt.grid(True)
    plt.xlabel('Grain ID by FIP rank')
    plt.xscale('log')
    plt.ticklabel_format(style = 'sci', axis='y', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig(os.path.join(store_dirr, '29_87_largest_SBA_FIP_per_grain'))
    plt.close()

def section_3_stress_strain_curve_30_90_instantiation_0():

    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_3')
    
    directory = os.path.join(DIR_LOC, r'paper_#2_section_3\90^3_That_We_Cut_30^3_From_Them\_Random_equiaxed_0')
    
    os.chdir(directory)

    size = np.asarray((30,30,30))
    padding = 30
    

    # Initialize empty arrays
    strain_z_90 = [0]
    stress_z_90 = [0]

    for num in np.arange(19,700,20):
        
        file_dirr = os.path.join(directory, 'QuadratureOutputs%d.csv' % num)
        
        print('Reading file: %s' % ('QuadratureOutputs%d.csv' % num))
        
        # Read in data using pandas module
        data2 = pd.read_csv(file_dirr, index_col = False)
        data1 = data2.sort_values(['z','y','x'], ascending = [True, True, True])

        mid_vals_x = data1.x.unique()[padding:padding+size[2]]
        mid_vals_y = data1.y.unique()[padding:padding+size[2]]
        mid_vals_z = data1.z.unique()[padding:padding+size[2]]
        
        mid_region = data1.loc[data1['x'].isin(mid_vals_x) & data1['y'].isin(mid_vals_y) & data1['z'].isin(mid_vals_z)]
        
        # Get average of strain in Z 
        strain_z_temp = np.mean(mid_region['Ezz'])
        strain_z_90.append(strain_z_temp)
        
        # Get average of stress in Z 
        stress_z_temp = np.mean(mid_region['Tzz'])
        stress_z_90.append(stress_z_temp)
        
        
    directory = os.path.join(DIR_LOC, r'paper_#2_section_3\30^3_from_90^3\_Random_equiaxed_0')
    os.chdir(directory)
    
    # Initialize empty arrays
    strain_z_30 = [0]
    stress_z_30 = [0]

    for num in np.arange(19,700,20):
        
        file_dirr = os.path.join(directory, 'QuadratureOutputs%d.csv' % num)
        
        print('Reading file: %s' % ('QuadratureOutputs%d.csv' % num))
        
        # Read in data using pandas module
        data2 = pd.read_csv(file_dirr, index_col = False)
        data1 = data2.sort_values(['z','y','x'], ascending = [True, True, True])

        # mid_vals_x = data1.x.unique()[padding:padding+size[2]]
        # mid_vals_y = data1.y.unique()[padding:padding+size[2]]
        # mid_vals_z = data1.z.unique()[padding:padding+size[2]]
        
        # mid_region = data1.loc[data1['x'].isin(mid_vals_x) & data1['y'].isin(mid_vals_y) & data1['z'].isin(mid_vals_z)]
        
        # Get average of strain in Z 
        strain_z_temp = np.mean(data1['Ezz'])
        strain_z_30.append(strain_z_temp)
        
        # Get average of stress in Z 
        stress_z_temp = np.mean(data1['Tzz'])
        stress_z_30.append(stress_z_temp)    
    
    
    
    
    # Plot stress-strain curve    
    
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
    
    plt.plot(strain_z_30,stress_z_30, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Non-periodic $30^3$ microstructure simulated with PBCs')
    plt.plot(strain_z_90,stress_z_90, marker = 'o', color = 'b', markersize = 2,                  label = '$30^3$ region extracted from $90^3$ microstructure')
    plt.plot(strain_z_30,stress_z_30, color = 'r', linestyle = ':')

    plt.legend(bbox_to_anchor=(0.0, 1.1), loc='upper left', framealpha = 1, fontsize = 9)
    
    #plt.show()
    plt.ylabel('Stress [MPa]')   
    plt.grid(True)
    plt.xlabel('Strain')
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig(os.path.join(store_dirr, '30_90_stress_strain_comparison'))
    plt.close()    

def section_3_plot_highest_SBA_per_grain_30_vs_90():
    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_3')
    
    # Initialize arrays
    all_30_fips = []
    all_90_fips = []
    
    
    for num in range(5):
        # Get FIPs from 87^3 first microstructure
        directory = os.path.join(DIR_LOC, r'paper_#2_section_3\90^3_That_We_Cut_30^3_From_Them\inst_files')
        os.chdir(directory)

        fname = r'sub_band_averaged_highest_per_grain_FS_FIP_%d.csv' % num
        data2 = pd.read_csv(fname, index_col = False)
        fips_90_pd = data2['SubBandAveragedFipValue']
        fips_90 = fips_90_pd.to_numpy()
        
        all_90_fips.append(fips_90)
        

        
        # Get FIPs from 29^3 first microstructure
        directory = os.path.join(DIR_LOC, r'paper_#2_section_3\30^3_from_90^3\inst_files')
        os.chdir(directory)

        fname = r'sub_band_averaged_highest_per_grain_FS_FIP_%d.csv' % num
        data1 = pd.read_csv(fname, index_col = False)
        fips_30_pd = data1['SubBandAveragedFipValue']
        fips_30 = fips_30_pd.to_numpy()
        
        all_30_fips.append(fips_30)



        # Plot figure
        
        fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
        
        plt.plot(range(1, len(fips_30)+1),fips_30, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Non-periodic $30^3$ microstructure simulated with PBCs')
        plt.plot(range(1, len(fips_90)+1),fips_90, marker = 'o', color = 'b', markersize = 2,                  label = '$30^3$ region extracted from $90^3$ microstructure')
        plt.plot(range(1, len(fips_30)+1),fips_30, color = 'r', linestyle = ':')

        plt.legend(loc='lower left', framealpha = 1, fontsize = 8.5)
        
        #plt.show()
        plt.ylabel('Sub-band-averaged FIP')   
        plt.grid(True)
        plt.xlabel('Grain ID by FIP rank')
        plt.xscale('log')
        plt.tight_layout()
        plt.savefig(os.path.join(store_dirr, '30_90_largest_SBA_FIP_per_grain_inst_%d' % num))
        plt.close()
        
        
    # Plot only the highest FIPs
    first_x_num_fips = 400
    
    # Compile the list of FIPs
    flat_90_fips = np.sort(np.concatenate(all_90_fips).ravel().tolist())[::-1][:first_x_num_fips]
    flat_30_fips = np.sort(np.concatenate(all_30_fips).ravel().tolist())[::-1][:first_x_num_fips]
    
    
    # Plot data
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
    
    plt.plot(range(1, len(flat_30_fips)+1),flat_30_fips, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Non-periodic $30^3$ microstructure simulated with PBCs')
    plt.plot(range(1, len(flat_90_fips)+1),flat_90_fips, marker = 'o', color = 'b', markersize = 2,                  label = '$30^3$ region extracted from $90^3$ microstructure')
    plt.plot(range(1, len(flat_30_fips)+1),flat_30_fips, color = 'r', linestyle = ':')

    plt.legend(loc='upper right', framealpha = 1, fontsize = 8.5)
    
    #plt.show()
    plt.ylabel('Sub-band-averaged FIP')   
    plt.grid(True)
    plt.xlabel('Grain ID by FIP rank')
    plt.xscale('log')
    plt.ticklabel_format(style = 'sci', axis='y', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig(os.path.join(store_dirr, 'ALL_30_90_largest_SBA_FIP_per_grain_first_%d_fips' % first_x_num_fips))
    plt.close()        
    
    
    
    
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
    
    plt.plot(range(1, len(flat_30_fips)+1),flat_30_fips, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Non-periodic $30^3$ microstructure simulated with PBCs')
    plt.plot(range(1, len(flat_90_fips)+1),flat_90_fips, marker = 'o', color = 'b', markersize = 2,                  label = '$30^3$ region extracted from $90^3$ microstructure')
    plt.plot(range(1, len(flat_30_fips)+1),flat_30_fips, color = 'r', linestyle = ':')

    plt.legend(loc='upper right', framealpha = 1, fontsize = 8.5)
    
    #plt.show()
    plt.ylabel('Sub-band-averaged FIP')   
    plt.grid(True)
    plt.xlabel('Grain ID by FIP rank')
    plt.ticklabel_format(style = 'sci', axis='y', scilimits=(0,0), useMathText = True)
    # plt.xscale('log')
    plt.tight_layout()
    plt.savefig(os.path.join(store_dirr, 'ALL_30_90_largest_SBA_FIP_per_grain_first_%d_fips_non_log' % first_x_num_fips))
    plt.close()           

def section_3_plot_local_slip_30_90():
    # Function to plot and compare local measures of slip 
    
    # Define directories
    dir_30_from_90 = os.path.join(DIR_LOC, r'paper_#2_section_3\30^3_from_90^3')
    dir_90_center  = os.path.join(DIR_LOC, r'paper_#2_section_3\90^3_That_We_Cut_30^3_From_Them')
    
    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_3')
    
    n_bins = 100
    
    for num in range(5):
    
        fname = os.path.join(dir_30_from_90, 'slip_values_%d.p' % num)
        h1 = open(fname, 'rb')
        eff_slip_30_from_90, slip_values_30_from_90 = p.load(h1)
        h1.close()
        
        fname1 = os.path.join(dir_90_center, 'slip_values_%d.p' % num)
        h2 = open(fname1, 'rb')
        eff_slip_90_center, slip_values_90_center = p.load(h2)
        h2.close() 
        

        if num == 0:
            fig = plt.figure(facecolor="white", figsize=(5, 3.666), dpi=1200)
        else:
            fig = plt.figure(facecolor="white", figsize=(5, 3.333), dpi=1200)
        
        n,x1,_ = plt.hist(eff_slip_30_from_90, bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers,n1, label = 'Non-periodic $30^3$ microstructure simulated with PBCs', color = 'b')
        
        
        n,x1,_ = plt.hist(eff_slip_90_center, bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers,n1, label = '$30^3$ region extracted from $90^3$ microstructure', linestyle = ':', color = 'r')        
        
        
        
        #plt.show()
        if num == 0:
            plt.legend(bbox_to_anchor=(0.09, 1.21), loc='upper left', framealpha = 1, fontsize = 8.5)
        plt.ylabel('Num')   
        plt.grid(True)
        plt.xlim(0,0.01)
        plt.ticklabel_format(style = 'sci', axis='both', scilimits=(0,0), useMathText = True)   
        if num == 4:
            plt.xlabel('Cumulative effective plastic strain')     
        plt.tight_layout()
        plt.savefig( os.path.join(store_dirr, '30_90_cumulative_effective_plastic_strain_histograms_%d_bins_inst_%d' % (n_bins, num)) )
        plt.close()

def section_3_plot_30_90_difference_in_grain_averaged_cumulative_effective_plastic_strain():
   
    # For directory as listed below
    # Get values for the 30^3 region extracted from the center of the 90^3 microstructure
    
    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_3')
    os.chdir(store_dirr)

    # Define directories
    directory_90 = os.path.join(DIR_LOC, r'paper_#2_section_3\90^3_That_We_Cut_30^3_From_Them\inst_files')
    directory_30 = os.path.join(DIR_LOC, r'paper_#2_section_3\30^3_from_90^3\inst_files')
    
    # Initialize arrays
    all_90_EpEff = []
    all_30_EpEff = []
    
    grain_centroids = []
    num_elems_all   = []
    
    # Define the center of the microstructures and plot values as a function of normalized distance from center of microstructure
    ms_center = np.repeat(112.5,3)
    
    for num in range(5):
    
        # "index_col = False" means that the first column is NOT the index, which is the case in the quadrature output files here.
        # "header = None" means there are no column headers
        
        
        temp_d1 = os.path.join(directory_90, 'grain_averaged_EpEff_%d.csv' % num)
        data90 = pd.read_csv(temp_d1, header = None).to_numpy().flatten()
        all_90_EpEff.append(data90)
        
        temp_d2 = os.path.join(directory_30, 'grain_averaged_EpEff_%d.csv' % num)
        data30 = pd.read_csv(temp_d2, header = None).to_numpy().flatten()
        all_30_EpEff.append(data30)
    
        # Get grain centroids
    


        df1 = pd.read_csv(os.path.join(directory_30, 'FeatureData_FakeMatl_%d_fixed.csv' % num), index_col = False)
        
        centroids = df1[['Centroids_0','Centroids_1','Centroids_2']].to_numpy(dtype=float)
        num_elems = df1['NumElements'].to_numpy(dtype=int)
        
        grain_centroids.append(centroids)
        num_elems_all.append(num_elems)



        distances = np.zeros((len(centroids)))

        for kk in range(len(centroids)):
            distances[kk] = np.linalg.norm(centroids[kk]-ms_center)

        distances_plot = distances / np.max(distances)

        # Compute diff for each grain averaged EpEff value
        perc_diff_eff = ( (data30 - data90) / data90 ) * 100



        plot_marker_size = 10

        
        ''' Feb 22nd plots'''
        # Still threshold by number of elements in the grain


        min_num_elem_grain = 20
        thresh_points = np.where(num_elems > min_num_elem_grain)
        

        # print('Average weighted perc diff for inst %d is %g' % (num, np.average(perc_diff_eff[thresh_points], weights = data90[thresh_points])))
        # print('Average perc diff for inst %d is %g' % (num, np.average(perc_diff_eff[thresh_points])))
       

        '''
        fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
        cm = plt.cm.get_cmap('jet')
        
        plt.scatter(distances_plot, perc_diff_eff, zorder = 2, s = plot_marker_size, c = data90,   cmap = cm , linewidths = 0.1, edgecolors = 'k')
        
        cbarr = plt.colorbar()
        cbarr.set_label("Grain Avg EpEff from $90^3$ sims") #, fontsize = 12)
        # plt.scatter(strain_z_29,stress_z_29, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Periodic $29^3$ microstructure simulated with PBCs')

        # plt.legend(bbox_to_anchor=(0.0, 1.1), loc='upper left', framealpha = 1, fontsize = 9)
        
        #plt.show()
        plt.ylabel('Percent difference in EpEff')   
        plt.grid(True, zorder = 1)
        # plt.ylim(-600, 120)
        plt.xlabel('Normalized distance from center of microstructure')
        plt.xlim(-0.01, 1.01)
        plt.ylim(-50, 100)
        # plt.axes(normed = True)
        plt.tight_layout()
        plt.savefig(os.path.join(store_dirr, 'grain_avg_EpEff_%d' % num))
        plt.close()
        
        

        # Hmm... consider a threshold ...
        
        # sorted_vals_1 = np.sort(data90)
        # plot_threshold = sorted_vals_1[int(-len(sorted_vals_1)*.5)]
        
        # Based on number of elements per grain
        min_num_elem_grain = 50
        thresh_points = np.where(num_elems > min_num_elem_grain)
        


        fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
        cm = plt.cm.get_cmap('jet')
        
        plt.scatter(distances_plot[thresh_points], perc_diff_eff[thresh_points], zorder = 2, s = plot_marker_size, c = num_elems[thresh_points],   cmap = cm , linewidths = 0.1, edgecolors = 'k')
        
        cbarr = plt.colorbar()
        cbarr.set_label("Grain Avg EpEff from $90^3$ sims") #, fontsize = 12)
        # plt.scatter(strain_z_29,stress_z_29, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Periodic $29^3$ microstructure simulated with PBCs')

        # plt.legend(bbox_to_anchor=(0.0, 1.1), loc='upper left', framealpha = 1, fontsize = 9)
        
        #plt.show()
        plt.ylabel('Percent difference in EpEff')   
        plt.grid(True, zorder = 1)
        # plt.ylim(-600, 120)
        plt.xlabel('Normalized distance from center of microstructure')
        plt.xlim(-0.01, 1.01)
        plt.ylim(-40, 40)
        # plt.axes(normed = True)
        plt.tight_layout()
        plt.savefig(os.path.join(store_dirr, 'grain_avg_EpEff_%d_num_elems_per_grain_%d_color_by_num_elems' % (num, min_num_elem_grain)))
        plt.close()  '''


        print('Perc below 0%% for inst %d is %g %%' % (  num, len(np.where(perc_diff_eff[thresh_points] < 0)[0]) / len(perc_diff_eff[thresh_points]) * 100   )  )
        
        fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)
        cm = plt.cm.get_cmap('jet')
        
        plt.scatter(distances_plot[thresh_points], perc_diff_eff[thresh_points], zorder = 2, s = plot_marker_size, c = data90[thresh_points],   cmap = cm , linewidths = 0.1, edgecolors = 'k')
        
        cbarr = plt.colorbar()
        cbarr.set_label("Grain Avg EpEff from $90^3$ sims") #, fontsize = 12)
        # plt.scatter(strain_z_29,stress_z_29, marker = 's', color = 'r', markersize = 2, linestyle = ':', label = 'Periodic $29^3$ microstructure simulated with PBCs')

        # plt.legend(bbox_to_anchor=(0.0, 1.1), loc='upper left', framealpha = 1, fontsize = 9)
        
        #plt.show()
        plt.ylabel('Percent difference in EpEff')   
        plt.grid(True, zorder = 1)
        # plt.ylim(-600, 120)
        plt.xlabel('Normalized distance from center of microstructure')
        plt.xlim(-0.01, 1.01)
        plt.ylim(-30, 30)
        # plt.axes(normed = True)
        plt.tight_layout()
        plt.savefig(os.path.join(store_dirr, '30_90_grain_avg_cumulative_effective_plastic_strain_%d_num_elem_thresh_%d' % (num, min_num_elem_grain)))
        plt.close()


'''
This second set of functions pull data from the directories with the following names and descriptions:

--> Simulations using the same 90 x 90 x 90 microstructure
extended_in_z_90x90x90_FreeSurface                    : Grip boundary condition
extended_in_z_90x90x90_FullyPeriodic                  : Fully periodic boundary condition
extended_in_z_90x90x90_MinimalBCs                     : Minimal boundary condition
extended_in_z_90x90x90_PeriodicFreeSurfaceAlong_Y     : "Thin film" boundary condition
extended_in_z_90x90x90_SymmetricFreeSurface           : Symmetry  boundary condition

--> Simulations with "grip" boundary condition; only the center 90 x 90 x 90 region is of interest
extended_in_z_90_90_110
extended_in_z_90_90_130
extended_in_z_90_90_160
extended_in_z_90_90_190
extended_in_z_90_90_250

--> Simulations with "minimal" boundary condition; only the center 90 x 90 x 90 region is of interest
extended_in_z_Minimal_90_90_110
extended_in_z_Minimal_90_90_130

--> Simulations with "symmetry" boundary condition; only the center 90 x 90 x 90 region is of interest
extended_in_z_Symmetric_90_90_110
extended_in_z_Symmetric_90_90_130

These 14 directories contain the data shown in Section 4 of the manuscript
'''


# First, the center 90^3 region from each of the extended microstructures needs to be extracted using the following function:

def section_4_extract_center_results():

    # Function to read in PRISMS results files and extract the center volume
    # Formulated to account for padding in the Z direction (see line 'sorted_1.z.unique()' below)
    
    # Inputs:
    #     padding     = Specify the number of elements that 'pad' the microstructure and should be removed
    #     size        = np.array((x,y,z)) size of the original microstructure

    # Define directories
    # Some are not considered because they were not extended in the Z direction
    directories = [# os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_FullyPeriodic'),
                   # os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_PeriodicFreeSurfaceAlong_Y'),
                   # os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_FreeSurface'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_110'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_130'), 
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_160'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_190'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_250'),
                   # os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_SymmetricFreeSurface'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Symmetric_90_90_110'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Symmetric_90_90_130'),
                   # os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_MinimalBCs'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Minimal_90_90_110'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Minimal_90_90_130')]

    # Define padding and size
    padding = [10, 20, 35, 50, 80, 10, 20, 10,20]
    size = np.asarray([90,90,90])

    # Iterate through directories
    for jj, directory in enumerate(directories):
        
        os.chdir(directory)

        # Run this for loop for "MaxTen..." below, then rerun for "MaxComp..."
        fname = os.path.join(directory, 'MaxComp_0.csv')
        
        print('Working on file: %s' % fname)

        c1 = pd.read_csv(fname, index_col = False)

        sorted_1 = c1.sort_values(['z','y','x'], ascending = [True, True, True])
        
        # Find elements of center 90^3 region
        mid_vals_x = sorted_1.x.unique()
        mid_vals_y = sorted_1.y.unique()
        mid_vals_z = sorted_1.z.unique()[padding[jj]:padding[jj]+size[2]]

        mid_region = sorted_1.loc[sorted_1['x'].isin(mid_vals_x) & sorted_1['y'].isin(mid_vals_y) & sorted_1['z'].isin(mid_vals_z)]

        # Save to a new file and rename with the suffix "middle"
        mid_region.to_csv(os.path.join(directory, 'MaxComp_0_middle.csv'), index = False)
     
     
     
        # Rerun for max tension files
        fname = os.path.join(directory, 'MaxTen_0.csv')
        
        print('Working on file: %s' % fname)

        c1 = pd.read_csv(fname, index_col = False)

        sorted_1 = c1.sort_values(['z','y','x'], ascending = [True, True, True])

        mid_vals_x = sorted_1.x.unique()
        mid_vals_y = sorted_1.y.unique()
        mid_vals_z = sorted_1.z.unique()[padding[jj]:padding[jj]+size[2]]

        mid_region = sorted_1.loc[sorted_1['x'].isin(mid_vals_x) & sorted_1['y'].isin(mid_vals_y) & sorted_1['z'].isin(mid_vals_z)]

        # Save to a new file and rename with the suffix "middle"
        mid_region.to_csv(os.path.join(directory, 'MaxTen_0_middle.csv'), index = False)

def section_4_extract_stress_strain_curves():

    # Define directories
    directories = [os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_FullyPeriodic'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_PeriodicFreeSurfaceAlong_Y\_Random_equiaxed_0'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_FreeSurface\_Random_equiaxed_0'), # OTHER INDIVIDUAL FILE FORMAT, ADD A 9
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_110\_Random_equiaxed_0'), # OTHER INDIVIDUAL FILE FORMAT, ADD A 9
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_130\_Random_equiaxed_0'), # OTHER INDIVIDUAL FILE FORMAT, VERY DIFFERENT
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_160\_Random_equiaxed_0'), # OTHER INDIVIDUAL FILE FORMAT, VERY DIFFERENT
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_190'), # OTHER INDIVIDUAL FILE FORMAT, VERY DIFFERENT
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_250\_Random_equiaxed_0'), # OTHER INDIVIDUAL FILE FORMAT, VERY DIFFERENT
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_SymmetricFreeSurface\_Random_equiaxed_0'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Symmetric_90_90_110\_Random_equiaxed_0'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Symmetric_90_90_130\_Random_equiaxed_0'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_MinimalBCs'), # OTHER INDIVIDUAL FILE FORMAT, VERY DIFFERENT
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Minimal_90_90_110'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Minimal_90_90_130')]
    
    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_4')
    
    # Define padding and size
    padding = [0, 0, 0, 10, 20, 35, 50, 80, 0, 10, 20, 0, 10, 20]
    size = np.repeat(90, 3)
    
    # Initialize arrays
    all_strain_data = []
    all_stress_data = []

    # Iterate through directories
    for directory, padds in zip(directories, padding):

        # Initialize empty arrays
        strain_z_90 = [0]
        stress_z_90 = [0]
        
        os.chdir(directory)
        
        # Get names of all .csv files
        tt = glob.glob('Quad*')
        
        # Get numbers 
        tt_nums = np.sort([int(re.findall('\d+', ii)[0]) for ii in tt])
        
        for num in tt_nums:
        # for num in np.arange(19,700,20):
            
            file_dirr = os.path.join(directory, 'QuadratureOutputs%d.csv' % num)
            
            print('Reading file: %s' % ('QuadratureOutputs%d.csv' % num))
            
            # Read in data using pandas module
            data2 = pd.read_csv(file_dirr, index_col = False)
            data1 = data2.sort_values(['z','y','x'], ascending = [True, True, True])

            mid_vals_x = data1.x.unique()
            mid_vals_y = data1.y.unique()
            mid_vals_z = data1.z.unique()[padds:padds+size[2]]
        
            mid_region = data1.loc[data1['x'].isin(mid_vals_x) & data1['y'].isin(mid_vals_y) & data1['z'].isin(mid_vals_z)]
        

            # Get average of strain in Z 
            strain_z_temp = np.mean(data1['Ezz'])
            strain_z_90.append(strain_z_temp)
            
            # Get average of stress in Z 
            stress_z_temp = np.mean(data1['Tzz'])
            stress_z_90.append(stress_z_temp)
        
        all_strain_data.append(strain_z_90)
        all_stress_data.append(stress_z_90)


    # Once the for loop above is finished, the data can be stored as a pickle file for efficient downstream reading:
    fname = 'stress_strain_paper_2_section_4.p'
    h1 = open(os.path.join(store_dirr, fname), 'wb')
    p.dump([all_strain_data, all_stress_data],h1)
    h1.close()    


    # Read in data previously stored
    fname = 'stress_strain_paper_2_section_4.p'
    h1 = open(os.path.join(store_dirr, fname), 'rb')
    all_strain_data, all_stress_data = p.load(h1)
    h1.close()    

    # Define labels for plots
    labelss = ['Periodic', 'Free surface Y', '90 x 90 x 90  grip', '90 x 90 x 110  grip', '90 x 90 x 130  grip', '90 x 90 x 160  grip', '90 x 90 x 190  grip', '90 x 90 x 250  grip',
                   '90 x 90 x 90     sym', '90 x 90 x 110   sym', '90 x 90 x 130   sym', '90 x 90 x 90     min', '90 x 90 x 110   min', '90 x 90 x 130   min']

    ''' Plot GRIP only '''
    
    to_plot_grip = [3, 4, 5, 6, 7, 0]
    
    linestyless = ['-', '-', '--', '-', '--', '-.', '-', '--', '-.', ':', '--', '-.', ':']    
    cfm = ['r', 'g', 'r', 'k', 'm', 'b', 'c', 'g', 'b', 'c', 'm', 'b', 'c']
    
    # fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
    # for rr in to_plot_grip:
        
    #     n,x1,_ = plt.hist(eff_slip_all[rr], bins = n_bins, histtype = 'step', color = 'white')
    #     n1 = n.astype(int)
    #     bin_centers = 0.5*(x1[1:]+x1[:-1])
    #     plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr])    

    
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)    
    for kkk in to_plot_grip:
        
        plt.plot(all_strain_data[kkk], all_stress_data[kkk], color = cfm[kkk], linestyle = linestyless[kkk], label = labelss[kkk], linewidth = 1)

    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    plt.legend(framealpha = 1)
    # plt.xlim(0.0005, 0.007)
    # plt.ylim(0, 36000)
    plt.ylabel('Stress [MPa]')   
    plt.grid(True)
    plt.xlabel('Strain')    
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_4_stress_strain_GRIP') )
    plt.close()    
    

    ''' GRIP ZOOM '''
    
    to_plot_grip = [3, 4, 5, 6, 7, 0]
    
    linestyless = ['-', '-', '--', '-', '--', '-.', '-', '--', '-.', ':', '--', '-.', ':']    
    cfm = ['r', 'g', 'r', 'k', 'm', 'b', 'c', 'g', 'b', 'c', 'm', 'b', 'c']
    
    # fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
    # for rr in to_plot_grip:
        
    #     n,x1,_ = plt.hist(eff_slip_all[rr], bins = n_bins, histtype = 'step', color = 'white')
    #     n1 = n.astype(int)
    #     bin_centers = 0.5*(x1[1:]+x1[:-1])
    #     plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr])    

    
    fig = plt.figure(facecolor="white", figsize=(4, 2.666), dpi=1200)    
    for kkk in to_plot_grip:
        
        plt.plot(all_strain_data[kkk], all_stress_data[kkk], color = cfm[kkk], linestyle = linestyless[kkk], label = labelss[kkk], linewidth = 1.75)

    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    # plt.legend(framealpha = 1)
    plt.xlim(0.006, 0.0071)
    plt.ylim(400, 490)
    # plt.ylabel('Stress [MPa]')   
    # plt.grid(True)
    # plt.xlabel('Strain')    
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_4_stress_strain_GRIP_zoom') )
    plt.close()    
    
    

    ''' Plot SYM only '''
    
    to_plot_grip = [8, 9, 10, 1, 0]
    linestyless = ['-', '-', '--','--', '--', '--', '-', '--', '--', '-.', ':']    
    cfm = ['r', 'g', 'r', 'r', 'r', 'r', 'r', 'm', 'm', 'b', 'c']
    
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)    
    for kkk in to_plot_grip:
    
        plt.plot(all_strain_data[kkk], all_stress_data[kkk], color = cfm[kkk], linestyle = linestyless[kkk], label = labelss[kkk], linewidth = 1)


    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    plt.legend(framealpha = 1)
    # plt.xlim(0.0005, 0.007)
    # plt.ylim(0, 36000)
    plt.ylabel('Stress [MPa]')   
    plt.grid(True)
    plt.xlabel('Strain')    
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_4_stress_strain_SYM') )
    plt.close()      

    

    ''' Plot MIN only '''
    
    to_plot_grip = [11, 12, 13, 1, 0]
    linestyless = ['-', '-', '--', '--', '--', '--', '-', '--', '--', '-.', ':', '--', '-.', ':']    
    cfm = ['r', 'g', 'r', 'r', 'r', 'r', 'r', 'm', 'm', 'b', 'c', 'm', 'b', 'c']
    
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)    
    for kkk in to_plot_grip:
        if kkk == 11:
            temp_rr = [] 
            for ttt in range(39):
                temp_rr.append(ttt)
            del temp_rr[10]
            del temp_rr[4]
            del temp_rr[2]
        
            plt.plot([all_strain_data[kkk][ttt1] for ttt1 in temp_rr], [all_stress_data[kkk][ttt1] for ttt1 in temp_rr], color = cfm[kkk], linestyle = linestyless[kkk], label = labelss[kkk], linewidth = 1)
        else:
            plt.plot(all_strain_data[kkk], all_stress_data[kkk], color = cfm[kkk], linestyle = linestyless[kkk], label = labelss[kkk], linewidth = 1)


    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    plt.legend(framealpha = 1)
    # plt.xlim(0.0005, 0.007)
    # plt.ylim(0, 36000)
    plt.ylabel('Stress [MPa]')   
    plt.grid(True)
    plt.xlabel('Strain')         
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_4_stress_strain_MIN') )
    plt.close()  

def section_4_extract_cumulative_effective_plastic_strain():

    # Define directories
    directories = [os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_FullyPeriodic'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_PeriodicFreeSurfaceAlong_Y'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_FreeSurface'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_110'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_130'), 
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_160'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_190'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90_90_250'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_SymmetricFreeSurface'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Symmetric_90_90_110'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Symmetric_90_90_130'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_90x90x90_MinimalBCs'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Minimal_90_90_110'),
                   os.path.join(DIR_LOC, r'paper_#2_section_4\extended_in_z_Minimal_90_90_130')]

    # Define names of files that should be read to extract cumulative effective plastic strain (final point of maximum compression)
    templ_f = ['maxTen_0.csv',
               'maxTen_0.csv',
               'maxTen_0.csv',
               'maxTen_0_middle.csv',
               'maxTen_0_middle.csv',
               'maxTen_0_middle.csv',
               'maxTen_0_middle.csv',
               'maxTen_0_middle.csv',
               'maxTen_0.csv',
               'maxTen_0_middle.csv',
               'maxTen_0_middle.csv',
               'maxTen_0.csv',
               'maxTen_0_middle.csv',
               'maxTen_0_middle.csv']
    
    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_4')
    
    # Initialize array
    eff_slip_all = []
    
    # Iterate through directories
    for ii, directory in enumerate(directories):
    
        print('In %s' % directory)
        os.chdir(directory)
        
        fname1 = os.path.join(directory, templ_f[ii])
        data1 = pd.read_csv(fname1, index_col = False)
        
        # "index_col = False" means that the first column is NOT the index, which is the case in the quadrature output files here.
       
        data2 = data1.sort_values(['z','y','x'], ascending = [True, True, True])
        
        eff_slip = data2['EpEff'].to_numpy()

        eff_slip_all.append(eff_slip)


    # Define colors for plots
    cfm1 = plt_cols.cm.Reds(np.linspace(0,1,5+1))[1:]
    cfm2 = plt_cols.cm.Blues(np.linspace(0,1,3+1))[1:]  
    
    # cfm3 = plt_cols.cm.Purples(np.linspace(0,1,1+1))[1:]
    cfm4 = plt_cols.cm.Greens(np.linspace(0,1,1+1))[1:]
    # cfm3 = plt_cols.cm.Greens(np.linspace(0,1,5))[3:4]
    
    # cfm = np.concatenate((cfm3, cfm4, cfm1, cfm2))
    cfm = np.concatenate((cfm4, cfm1, cfm2))


    n_bins = 100

    # Plot cumulative effective plastic strain for the three symmetric scenarios

    labelss = ['Periodic', 'Free surface Y', '90 x 90 x 90  grip', '90 x 90 x 110  grip', '90 x 90 x 130  grip', '90 x 90 x 160  grip', '90 x 90 x 190  grip', '90 x 90 x 250  grip',
                   '90 x 90 x 90     sym', '90 x 90 x 110   sym', '90 x 90 x 130   sym', '90 x 90 x 90     min', '90 x 90 x 110   min', '90 x 90 x 130   min']


    ''' Plot GRIP only '''
    
    to_plot_grip = [3, 4, 5, 6, 7, 0]
    
    linestyless = ['-', '-', '--', '-', '--', '-.', '-', '--', '-.', ':', '--', '-.', ':']    
    cfm = ['r', 'g', 'r', 'k', 'm', 'b', 'c', 'g', 'b', 'c', 'm', 'b', 'c']
    
    fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
    for rr in to_plot_grip:
        
        n,x1,_ = plt.hist(eff_slip_all[rr], bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr])    


    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    plt.legend(framealpha = 1)
    plt.xlim(0.0005, 0.007)
    plt.ylim(0, 36000)
    plt.ylabel('Num')   
    plt.grid(True)
    plt.xlabel('Cumulative effective plastic strain')
    plt.ticklabel_format(style = 'sci', axis='both', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_4_hists_v1_GRIP_%d_bins' % n_bins) )
    plt.close()    


    
    ''' Plot SYM only '''
    
    to_plot_grip = [8, 9, 10, 1, 0]
    linestyless = ['-', '-', '--','--', '--', '--', '-', '--', '--', '-.', ':']    
    cfm = ['r', 'g', 'r', 'r', 'r', 'r', 'r', 'm', 'm', 'b', 'c']
    
    fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
    for rr in to_plot_grip:
        
        n,x1,_ = plt.hist(eff_slip_all[rr], bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], marker = 's', markersize = 4)    
        plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], markersize = 2)    


    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    plt.legend(framealpha = 1)
    plt.xlim(0.0005, 0.007)
    plt.ylim(0, 36000)
    plt.ylabel('Num')   
    plt.grid(True)
    plt.xlabel('Cumulative effective plastic strain')
    plt.ticklabel_format(style = 'sci', axis='both', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_4_hists_v1_SYM_%d_bins' % n_bins) )
    plt.close()        


    
    ''' Plot MIN only '''
    
    to_plot_grip = [11, 12, 13, 1, 0]
    linestyless = ['-', '-', '--', '--', '--', '--', '-', '--', '--', '-.', ':', '--', '-.', ':']    
    cfm = ['r', 'g', 'r', 'r', 'r', 'r', 'r', 'm', 'm', 'b', 'c', 'm', 'b', 'c']
    
    fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
    for rr in to_plot_grip:
        
        n,x1,_ = plt.hist(eff_slip_all[rr], bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], marker = 's', markersize = 4)    
        plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], markersize = 2)    


    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    plt.legend(framealpha = 1)
    plt.xlim(0.0005, 0.007)
    plt.ylim(0, 36000)
    plt.ylabel('Num')   
    plt.grid(True)
    plt.xlabel('Cumulative effective plastic strain')         
    plt.ticklabel_format(style = 'sci', axis='both', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_4_hists_v1_MIN_%d_bins' % n_bins) )
    plt.close()            
    
    
    ''' Plot 90 x 90 x 130 only '''

    labelss = ['Periodic', 'Free surface Y', '90 x 90 x 90  grip', '90 x 90 x 110  grip', '90 x 90 x 130  grip', '90 x 90 x 160  grip', '90 x 90 x 190  grip', '90 x 90 x 250  grip',
                   '90 x 90 x 90     sym', '90 x 90 x 110   sym', '90 x 90 x 130  sym', '90 x 90 x 90     min', '90 x 90 x 110   min', '90 x 90 x 130  min']
                   
    to_plot_grip = [4, 10, 13, 1, 0]
    linestyless = ['-', '-', '--', '--', '--', '--', '-', '-.', '--', '-.', '-.', '--', '-.', ':']    
    cfm = ['r', 'g', 'r', 'k', 'm', 'r', 'r', 'm', 'm', 'b', 'b', 'm', 'b', 'c']
    
    fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
    for rr in to_plot_grip:
        
        n,x1,_ = plt.hist(eff_slip_all[rr], bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], marker = 's', markersize = 4)    
        plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], markersize = 2)    


    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    plt.legend(framealpha = 1)
    plt.xlim(0.0005, 0.007)
    plt.ylim(0, 36000)
    plt.ylabel('Num')   
    plt.grid(True)
    plt.xlabel('Cumulative effective plastic strain')         
    plt.ticklabel_format(style = 'sci', axis='both', scilimits=(0,0), useMathText = True)
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_4_hists_v1_90_90_130_%d_bins' % n_bins) )
    plt.close()        
    
    # The following lines are to create additional plots
    
    # ''' Plot compare 90 x 90 x 110 only '''
        
        # to_plot_grip = [7, 2, 0]
        # linestyless = ['-', '--', '--', '--', '--', '-', '--', ':', ':']    
        # cfm = ['g', 'r', 'r', 'r', 'r', 'r', 'm', 'b', 'c']
        
        # fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
        # for rr in to_plot_grip:
            
            # n,x1,_ = plt.hist(eff_slip_all[rr], bins = n_bins, histtype = 'step', color = 'white')
            # n1 = n.astype(int)
            # bin_centers = 0.5*(x1[1:]+x1[:-1])
            # # plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], marker = 's', markersize = 4)    
            # plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], markersize = 2)    


        # #plt.show()
        # # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
        # plt.legend(framealpha = 1)
        # plt.xlim(0, 0.008)
        # plt.ylabel('Num')   
        # plt.grid(True)
        # plt.xlabel('Effective plastic shear strain per int point')       
        # plt.tight_layout()
        # plt.savefig( os.path.join(store_dirr, 'section_4_hists_v1_SYM_%d_bins_110' % n_bins) )
        # plt.close()           
        

    
    # ''' Plot compare 90 x 90 x 130 only '''
                
        # to_plot_grip = [8, 3, 0]
        # linestyless = ['-', '--', '--', '--', '--', '-', '--', '-.', ':']    
        # cfm = ['g', 'r', 'r', 'r', 'r', 'r', 'm', 'b', 'b']
        
        # fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
        # for rr in to_plot_grip:
            
            # n,x1,_ = plt.hist(eff_slip_all[rr], bins = n_bins, histtype = 'step', color = 'white')
            # n1 = n.astype(int)
            # bin_centers = 0.5*(x1[1:]+x1[:-1])
            # # plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], marker = 's', markersize = 4)    
            # plt.plot(bin_centers,n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr], markersize = 2)    


        # #plt.show()
        # # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
        # plt.legend(framealpha = 1)
        # plt.xlim(0, 0.008)
        # plt.ylabel('Num')   
        # plt.grid(True)
        # plt.xlabel('Effective plastic shear strain per int point')       
        # plt.tight_layout()
        # plt.savefig( os.path.join(store_dirr, 'section_4_hists_v1_SYM_%d_bins_130' % n_bins) )
        # plt.close()              

        

        # ''' individual plots '''
        # # Free surface Y
        # n,x1,_ = plt.hist(eff_slip_all[0], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = 'Free surface Y', color = cfm[0])
        
        # '''
        # # GRIP 
        # n,x1,_ = plt.hist(eff_slip_all[1], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = '90 x 90 x 90  grip', linestyle = ':', color = cfm[1])  '''
        
        # n,x1,_ = plt.hist(eff_slip_all[2], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = '90 x 90 x 110 grip', linestyle = ':', color = cfm[2])  
        
        # n,x1,_ = plt.hist(eff_slip_all[3], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = '90 x 90 x 130 grip', color = cfm[3])
        
        # n,x1,_ = plt.hist(eff_slip_all[4], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = '90 x 90 x 160 grip', linestyle = ':', color = cfm[4])      
        
        # n,x1,_ = plt.hist(eff_slip_all[5], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = '90 x 90 x 250 grip', color = cfm[5])
        
        
        
        # # SYM
        
        # n,x1,_ = plt.hist(eff_slip_all[6], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = '90 x 90 x 90   sym', color = cfm[6])
        
        # n,x1,_ = plt.hist(eff_slip_all[7], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = '90 x 90 x 110 sym', linestyle = ':', color = cfm[7])        
        
        # n,x1,_ = plt.hist(eff_slip_all[8], bins = n_bins, histtype = 'step', color = 'white')
        # n1 = n.astype(int)
        # bin_centers = 0.5*(x1[1:]+x1[:-1])
        # plt.plot(bin_centers,n1, label = '90 x 90 x 130 sym', linestyle = '-.', color = cfm[8])            
        
        
        
        # #plt.show()
        # # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
        # plt.legend(framealpha = 1)
        # plt.ylabel('Num')   
        # plt.grid(True)
        # plt.xlabel('Effective plastic shear strain per int point')       
        # plt.tight_layout()
        # plt.savefig( os.path.join(store_dirr, 'section_4_hists_v1_%d_bins' % n_bins) )
        # plt.close()     


    fname = 'effect_plastic_shear_strain_all_section_4.p'
    h1 = open(os.path.join(store_dirr, fname), 'wb')
    p.dump(eff_slip_all,h1)
    h1.close()
    
    
'''
This third and last set of functions pull data from the directories with the following names and descriptions:

--> Cubic textured microstructures with fully periodic and "thin film" boundary conditions
90^3_cubic_fully_periodic_equiaxed_FullyPeriodic_LoadAlongX
90^3_cubic_fully_periodic_equiaxed_PeriodicFreeSurfaceAlong_Y_LoadAlongX

--> Rolled textured microstructures with fully periodic and "thin film" boundary conditions
90^3_rolled_fully_periodic_equiaxed_FullyPeriodic_LoadAlongX
90^3_rolled_fully_periodic_equiaxed_PeriodicFreeSurfaceAlong_Y_LoadAlongX

--> Random textured microstructures with fully periodic and "thin film" boundary conditions
extended_in_z_90x90x90_FullyPeriodic_LoadAlongX
extended_in_z_90x90x90_PeriodicFreeSurfaceAlong_Y_LoadAlongX


These six directories contain part of the data shown in Section 5 of the manuscript (only for the 90 x 90 x 90 microstructures)
'''

def section_5_extract_stress_strain_curves():

    # The plots generated by this function can also be created using the "stressstrain.txt" files from the PRISMS-Plasticity simulations

    # Define directories with data
    directories = [os.path.join(DIR_LOC, r'paper_#2_section_5\90^3_cubic_fully_periodic_equiaxed_FullyPeriodic_LoadAlongX'),
                   os.path.join(DIR_LOC, r'paper_#2_section_5\extended_in_z_90x90x90_FullyPeriodic_LoadAlongX'),
                   os.path.join(DIR_LOC, r'paper_#2_section_5\90^3_rolled_fully_periodic_equiaxed_FullyPeriodic_LoadAlongX')]

    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_5')
    os.chdir(store_dirr)   
    
    # Initialize arrays
    all_strain_data = []
    all_stress_data = []

    # Iterate through directories
    for directory in directories:

        # Initialize empty arrays
        strain_z_90 = [0]
        stress_z_90 = [0]

        # Iterate through individual quadrature output files
        for num in np.arange(19,700,20):
            
            # Define file name
            file_dirr = os.path.join(directory, 'QuadratureOutputs%d.csv' % num)
            
            print('Reading file: %s' % ('QuadratureOutputs%d.csv' % num))
            
            # Read in data using pandas module
            data2 = pd.read_csv(file_dirr, index_col = False)
            data1 = data2.sort_values(['z','y','x'], ascending = [True, True, True])

            # Get average of strain in Z 
            strain_z_temp = np.mean(data1['Exx'])
            strain_z_90.append(strain_z_temp)
            
            # Get average of stress in Z 
            stress_z_temp = np.mean(data1['Txx'])
            stress_z_90.append(stress_z_temp)
        
        all_strain_data.append(strain_z_90)
        all_stress_data.append(stress_z_90)


    # Plot stress-strain curve    
    colorss = ['r', 'b', 'g']
    linestyless = ['-', ':', '--']
    markerss = ['o', 's', '^']
    labells = ['Cubic', 'Random', 'Rolled']
    
    
    fig = plt.figure(facecolor="white", figsize=(5.5, 3.666), dpi=1200)    
    for kkk in np.arange(0,3,1):
    
        plt.plot(all_strain_data[kkk], all_stress_data[kkk] , marker = markerss[kkk], color = colorss[kkk], markersize = 2, linestyle = linestyless[kkk], label = labells[kkk], linewidth = 1)
    
    plt.legend(framealpha = 1)
    
    # plt.show()
    plt.ylabel('Stress [MPa]')   
    plt.grid(True)
    plt.xlabel('Strain')
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)        
    plt.tight_layout()
    plt.savefig(os.path.join(store_dirr, 'textures_stress_strain_along_x'))
    plt.close()    
    
    # Store data for quicker plotting
    fname = 'stress_strain_paper_2_section_5_textures.p'
    h1 = open(os.path.join(store_dirr, fname), 'wb')
    p.dump([all_strain_data, all_stress_data],h1)
    h1.close()    

def section_5_paper_2_plot_max_and_cumulative_slip():

    # Define directories with data
    directories = [os.path.join(DIR_LOC, r'paper_#2_section_5\90^3_cubic_fully_periodic_equiaxed_FullyPeriodic_LoadAlongX'),
                   os.path.join(DIR_LOC, r'paper_#2_section_5\90^3_cubic_fully_periodic_equiaxed_PeriodicFreeSurfaceAlong_Y_LoadAlongX'),
                   os.path.join(DIR_LOC, r'paper_#2_section_5\extended_in_z_90x90x90_FullyPeriodic_LoadAlongX'),
                   os.path.join(DIR_LOC, r'paper_#2_section_5\extended_in_z_90x90x90_PeriodicFreeSurfaceAlong_Y_LoadAlongX'),
                   os.path.join(DIR_LOC, r'paper_#2_section_5\90^3_rolled_fully_periodic_equiaxed_FullyPeriodic_LoadAlongX'),
                   os.path.join(DIR_LOC, r'paper_#2_section_5\90^3_rolled_fully_periodic_equiaxed_PeriodicFreeSurfaceAlong_Y_LoadAlongX')]

    # Define where to save plot
    store_dirr = os.path.join(DIR_LOC, r'paper_#2_section_5')
    os.chdir(store_dirr)   
    
    # Initialize arrays
    eff_slip_all         = []
    max_slip_per_int_all = []
    
    # Iterate through directories
    for ii, directory in enumerate(directories):
    
        print('In %s' % directory)
        
        # Specify files with simulations values at points of maximum compression and maximum tension
        dirr_max_comp = os.path.join(directory, 'MaxComp_0.csv')
        dirr_max_tens = os.path.join(directory, 'maxTen_0.csv')

        # Read in data using pandas module
        aver_comp = pd.read_csv(dirr_max_comp, index_col = False)
        aver_tens = pd.read_csv(dirr_max_tens, index_col = False)
        # "index_col = False" means that the first column is NOT the index, which is the case in the quadrature output files here.

        # Sort data
        aver_comp_2_sorted = aver_comp.sort_values(['z','y','x'], ascending = [True, True, True])
        aver_tens_2_sorted = aver_tens.sort_values(['z','y','x'], ascending = [True, True, True])

        # Extract cumulative effective shear strain at each integration point
        eff_slip = aver_tens_2_sorted['EpEff'].to_numpy()
        eff_slip_all.append(eff_slip)    
        
        # Calculate plastic shear strain range
        delta_gamma = (aver_tens_2_sorted - aver_comp_2_sorted) 
        slip_values = abs(delta_gamma[['slip_' + str(i) for i in range(1,13)]]).to_numpy()
        
        # Calculate maximum value of plastic shear strain range for each integration point
        max_slip_per_int = np.max(slip_values, axis = 1)
        max_slip_per_int_all.append(max_slip_per_int)
    
    # Define ranges for plots
    cumulative_range = [0.025e-2, 1.2e-2]
    max_slip_range   = [0.05e-3, 5e-3]
    
    cumulative_y_max = 55000
    max_slip_y_max   = 75000
    

    # Condense 3 x 2 plots into two plots
    labelss = ['Cubic Periodic', 'Cubic Free Surface', 'Random Periodic', 'Random Free Surface', 'Rolled Periodic', 'Rolled Free surface']
    cfm     = ['r', 'r', 'b', 'b', 'g', 'g']
    linestyless = ['-', ':', '-', ':', '-', ':']
    
    n_bins = 100
    
    
    ''' Plot cumulative effective plastic strains '''
    fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
    for rr, valss in enumerate(eff_slip_all):
        
        n,x1,_ = plt.hist(valss, bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers, n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr])    


    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    plt.legend(framealpha = 1, fontsize = 8)
    plt.xlim(cumulative_range[0], cumulative_range[1])
    # plt.ylim(0, cumulative_y_max)
    plt.ylabel('Num')   
    plt.grid(True)
    plt.xlabel('Cumulative effective plastic strain')       
    plt.ticklabel_format(style = 'sci', axis='both', scilimits=(0,0), useMathText = True)    
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_5_all_cumulative_%d_bins_loaded_in_X' % n_bins) )
    plt.close()    
    

    labelss = ['Cubic Periodic', 'Cubic Free Surface', 'Random Periodic', 'Random Free Surface', 'Rolled Periodic', 'Rolled Free surface']
    cfm     = ['r', 'r', 'b', 'b', 'g', 'g']
    linestyless = ['-', ':', '-', ':', '-', ':']
    
    ''' ZOOM '''
    
    n_bins = 100
    
    fig = plt.figure(facecolor="white", figsize=(4, 2.5), dpi=1200)
    for rr, valss in enumerate(eff_slip_all):
        
        n,x1,_ = plt.hist(valss, bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers, n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr])    


    # plt.show()
    # plt.legend(bbox_to_anchor=(0.0, 1.18), loc='upper left', framealpha = 1, fontsize = 9)
    # plt.legend(framealpha = 1, fontsize = 8)
    plt.xlim(0.6e-2, 1.1e-2)
    plt.ylim(0, 100)
    # plt.ylabel('Num')   
    plt.grid(True)
    # plt.xlabel('Cumulative effective plastic strain')       
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)    
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_5_all_cumulative_%d_bins_zoom_loaded_in_X' % n_bins) )
    plt.close()    
    
    
    
    ''' Plot maximum plastic shear strain range per integration point/element '''

    n_bins = 100
    
    fig = plt.figure(facecolor="white", figsize=(6, 4), dpi=1200)
    for rr, valss in enumerate(max_slip_per_int_all):
        
        n,x1,_ = plt.hist(valss, bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers, n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr])    

    # plt.show()
    plt.legend(framealpha = 1, fontsize = 8)
    plt.xlim(max_slip_range[0], max_slip_range[1])
    plt.ylabel('Num')   
    plt.grid(True)
    plt.xlabel('Maximum plastic shear strain range')     
    plt.ticklabel_format(style = 'sci', axis='both', scilimits=(0,0), useMathText = True)    
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_5_all_max_PSSR_%d_bins_loaded_in_X' % n_bins) )
    plt.close()          


    
    ''' Max slip per int point! '''
    ''' ZOOM '''
    
    n_bins = 100
    
    fig = plt.figure(facecolor="white", figsize=(5, 3), dpi=1200)
    for rr, valss in enumerate(max_slip_per_int_all):
        
        n,x1,_ = plt.hist(valss, bins = n_bins, histtype = 'step', color = 'white')
        n1 = n.astype(int)
        bin_centers = 0.5*(x1[1:]+x1[:-1])
        plt.plot(bin_centers, n1, label = labelss[rr], color = cfm[rr], linestyle = linestyless[rr])    

    # plt.show()
    plt.xlim(1e-3, max_slip_range[1])
    plt.ylim(0, 100)
    # plt.ylabel('Num')   
    plt.grid(True)
    # plt.xlabel('Maximum plastic shear strain range')     
    plt.ticklabel_format(style = 'sci', axis='x', scilimits=(0,0), useMathText = True)    
    plt.tight_layout()
    plt.savefig( os.path.join(store_dirr, 'section_5_all_max_PSSR_%d_bins_zoom_loaded_in_X' % n_bins) )
    plt.close()          
   
def main():
    # Users can comment out the lines below to execute only certain sections of this script
    # In fact, this entire script will take some time to run, so users may want to execute only a few of the functions at a time
    
    ''' Section 3 functions '''
    # Plot stress-strain curves from 29^3 and 87^3 microstructure
    section_3_stress_strain_curve_29_87_instantiation_0()
    
    # Extract results from center regions
    section_3_extract_center_results()
    
    # Store results from center regions
    section_3_extract_and_store_local_values()
    
    # Plot comparisons of cumulative effective plastic strain
    section_3_plot_local_slip_29_87()
    
    # Plot comparison of FIPs
    section_3_plot_highest_SBA_per_grain_29_87()
    
    # Plot stress-strain curves from 30^3 and 90^3 microstructure
    section_3_stress_strain_curve_30_90_instantiation_0()
    
    # Compare FIPs from from 30^3 and 90^3 microstructures
    section_3_plot_highest_SBA_per_grain_30_vs_90()
    
    # Plot comparison of cumulative effective plastic strain for the 30^3 and 90^3 microstructures
    section_3_plot_local_slip_30_90()
    
    # Plot difference in grain averaged cumulative effective plastic strain for the 30^3 and 90^3 microstructures
    section_3_plot_30_90_difference_in_grain_averaged_cumulative_effective_plastic_strain()
    
    
    ''' Section 4 functions '''
    # Extract results from the center 90^3 regions of the microstructures extended in the Z direction
    section_4_extract_center_results()
    
    # Plot stress-strain curves
    section_4_extract_stress_strain_curves()
    
    # Plot cumulative effective plastic strain
    section_4_extract_cumulative_effective_plastic_strain()
    
    
    ''' Section 5 functions '''
    
    # Plot stress-strain curves
    section_5_extract_stress_strain_curves()
    
    # Plot cumulative effective plastic strain and maximum plastic shear strain range
    section_5_paper_2_plot_max_and_cumulative_slip()
    
if __name__ == "__main__":
    main()
